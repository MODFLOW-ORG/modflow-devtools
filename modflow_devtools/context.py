import json
import os
import shutil
import subprocess
import sys
import tarfile
import timeit
from enum import Enum

import flopy
from modflow_devtools.build import meson_build
from modflow_devtools.http import get_request
from modflow_devtools.usgsprograms import usgs_program_data
from modflow_devtools.zip import MFZipFile


class MFTargetType(Enum):
    TEST = 1
    RELEASE = 2
    REGRESSION = 3


class MFTestTargets:
    """define test targets for modflow tests"""

    def __init__(
        self,
        testbin: str = None,
        releasebin: str = None,
        builtbin: str = None,
        use_path: bool = False,
    ):
        """MFTestTargets init"""

        self._exe_targets = {
            "mf6": {"exe": "mf6", "type": MFTargetType.TEST},
            "mf5to6": {"exe": "mf5to6", "type": MFTargetType.TEST},
            "zbud6": {"exe": "zbud6", "type": MFTargetType.TEST},
            "libmf6": {"exe": None, "type": MFTargetType.TEST},
            "mf2005": {"exe": "mf2005dbl", "type": MFTargetType.RELEASE},
            "mfnwt": {"exe": "mfnwtdbl", "type": MFTargetType.RELEASE},
            "mfusg": {"exe": "mfusgdbl", "type": MFTargetType.RELEASE},
            "mflgr": {"exe": "mflgrdbl", "type": MFTargetType.RELEASE},
            "mf2005s": {"exe": "mf2005", "type": MFTargetType.RELEASE},
            "mt3dms": {"exe": "mt3dms", "type": MFTargetType.RELEASE},
            "mf6-regression": {"exe": "mf6", "type": MFTargetType.REGRESSION},
        }

        self._testbin = testbin
        self._releasebin = releasebin
        self._builtbin = builtbin
        self._use_path = use_path
        self._target_path_d = None

    def set_targets(self):
        """
        set target paths from current bin directories
        """
        self._set_targets()

    def target_paths(self):
        """
        get the target path dictionary generated by set_targets
        """
        return self._target_path_d

    def get_mf6_version(self, version=None):
        """
        get version of mf6 entry in _exe_targets
        """
        return self._mf6_target_version(target=version)

    def target_exe_d(self):
        """
        get the _exe_targets dictionary
        """
        return self._exe_targets

    def release_exe_names(self):
        """
        get name list of release executables
        """
        target_ext, target_so = self._extensions()
        return [
            f"{self._exe_targets[t]['exe']}{target_ext}"
            for t in self._exe_targets
            if self._exe_targets[t]["type"] == MFTargetType.RELEASE
            and self._exe_targets[t]["exe"]
        ]

    def release_lib_names(self):
        """
        get name list of release libs
        """
        target_ext, target_so = self._extensions()
        return [
            f"{self._exe_targets[t]}{target_so}"
            for t in self._exe_targets
            if self._exe_targets[t]["type"] == MFTargetType.RELEASE
            and self._exe_targets[t]["exe"] is None
        ]

    def regression_exe_names(self):
        """
        get name list of regression executables
        """
        target_ext, target_so = self._extensions()
        return [
            f"{self._exe_targets[t]['exe']}{target_ext}"
            for t in self._exe_targets
            if self._exe_targets[t]["type"] == MFTargetType.REGRESSION
            and self._exe_targets[t]["exe"]
        ]

    def regression_lib_names(self):
        """
        get name list of regression libs
        """
        target_ext, target_so = self._extensions()
        return [
            f"{self._exe_targets[t]}{target_so}"
            for t in self._exe_targets
            if self._exe_targets[t]["type"] == MFTargetType.REGRESSION
            and self._exe_targets[t]["exe"] is None
        ]

    def _target_pth(self, target, target_t=None, is_lib=False):
        if target_t == MFTargetType.TEST:
            path = self._testbin
        elif target_t == MFTargetType.REGRESSION:
            path = self._builtbin
        elif target_t == MFTargetType.RELEASE:
            path = self._releasebin

        if target_t != MFTargetType.TEST and self._use_path:
            exe_exists = flopy.which(target)
        else:
            exe_exists = flopy.which(target, path=path)

        if (
            exe_exists is None
            and is_lib
            and os.path.isfile(os.path.join(path, target))
        ):
            exe_exists = os.path.join(path, target)

        if exe_exists is None:
            print(target)
            raise Exception(
                f"{target} does not exist or is not executable in test context."
            )

        return os.path.abspath(exe_exists)

    def _run_exe(self, argv, ws="."):
        buff = []
        proc = subprocess.Popen(
            argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=ws
        )
        result, error = proc.communicate()
        if result is not None:
            c = result.decode("utf-8")
            c = c.rstrip("\r\n")
            # print(f"{c}")
            buff.append(c)

        return proc.returncode, buff

    def _mf6_target_version(self, target=None):
        exe = self._target_path_d[target]
        return_code, buff = self._run_exe((exe, "-v"))
        if return_code == 0:
            version = buff[0].split()[1]
        else:
            version = None
        return version

    def _set_targets(self):
        self._target_path_d = None
        target_ext, target_so = self._extensions()

        self._target_path_d = {}
        for t in list(self._exe_targets):
            is_lib = False
            if self._exe_targets[t]["exe"] is None:
                name = f"{t}{target_so}"
                is_lib = True
            else:
                name = f"{self._exe_targets[t]['exe']}{target_ext}"

            target = self._target_pth(
                name, target_t=self._exe_targets[t]["type"], is_lib=is_lib
            )
            self._target_path_d[t] = target

    def _extensions(self):
        target_ext = ""
        target_so = ".so"
        sysinfo = sys.platform.lower()
        if sysinfo.lower() == "win32":
            target_ext = ".exe"
            target_so = ".dll"
        elif sysinfo.lower() == "darwin":
            target_so = ".dylib"

        return target_ext, target_so


class MFTestContext:
    """setup test context for modflow tests"""

    def __init__(
        self,
        testbin: str = None,
        use_path: bool = False,
        update_exe: bool = False,
    ):
        """MFTestContext init"""

        self._testbin = os.path.abspath(testbin)
        self._releasebin = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "bin")
        )

        builtbin = os.path.join(self._releasebin, "rebuilt")

        self._update = update_exe

        self._targets = MFTestTargets(
            testbin=testbin,
            releasebin=self._releasebin,
            builtbin=builtbin,
            use_path=use_path,
        )

        self._exe = MFTestExe(
            releasebin=self._releasebin,
            builtbin=builtbin,
            targets=self._targets,
        )

        self._update_context()

    def get_target_dictionary(self):
        """
        get target path dictionary
        """
        return self._targets.target_paths()

    def get_mf6_version(self, version="mf6"):
        """
        get mf6 version
        """
        return self._targets.get_mf6_version(version=version)

    def _update_context(self):
        if not self._exe.verify_exe() or (
            self._update and not self._exe.releases_current()
        ):
            self._exe.cleanup()
            self._exe.build_mf6_release()

        self._targets.set_targets()


class MFTestExe:
    """update and/or verify regression executables for test"""

    def __init__(
        self,
        releasebin: str = None,
        builtbin: str = None,
        targets: object = None,
    ):
        """MFTestExe init"""

        self._releasebin = releasebin
        self._builtbin = builtbin
        self._targets = targets
        self._working_dir = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "temp")
        )

    def verify_exe(self):
        """
        verify downloaded and built exe exist
        """
        if not (
            os.path.isdir(self._releasebin) or os.path.isdir(self._builtbin)
        ):
            return False

        for t in self._targets.release_exe_names():
            if not os.path.isfile(os.path.join(self._releasebin, t)):
                return False

        for t in self._targets.release_lib_names():
            if not os.path.isfile(os.path.join(self._releasebin, t)):
                return False

        for t in self._targets.regression_exe_names():
            if not os.path.isfile(os.path.join(self._builtbin, t)):
                return False

        for t in self._targets.regression_lib_names():
            if not os.path.isfile(os.path.join(self._builtbin, t)):
                return False

        return True

    def releases_current(self):
        """
        check downloaded versions against local db versions
        """
        try:
            with open(os.path.join(self._releasebin, "code.json")) as fh:
                release_d = json.load(fh)
        except:
            return False

        program_d = usgs_program_data.get_program_dict()
        exe_d = self._targets.target_exe_d()
        if release_d and program_d:
            for t in exe_d:
                if t in release_d:
                    key = t
                elif exe_d[t]["exe"] in release_d:
                    key = exe_d[t]["exe"]
                if (
                    key not in release_d
                    or release_d[key]["version"] != program_d[key]["version"]
                ):
                    return False

            return True

        return False

    def build_mf6_release(self):
        """
        download mf6 release source and build exe
        """
        self._build_mf6_release()

    def cleanup(self):
        """
        remove bins when possible
        """
        shutil.rmtree(self._builtbin, ignore_errors=True)
        shutil.rmtree(self._releasebin, ignore_errors=True)

    def _create_dirs(self):
        pths = [self._releasebin, self._working_dir]
        for pth in pths:
            print(f"creating... {os.path.abspath(pth)}")
            os.makedirs(pth, exist_ok=True)
            errmsg = f"could not create... {os.path.abspath(pth)}"
            assert os.path.exists(pth), errmsg

    def _build_mf6_release(self):
        target_dict = usgs_program_data.get_target("mf6")

        download_and_unzip(
            target_dict["url"],
            pth=self._working_dir,
            verbose=True,
        )

        # update IDEVELOP MODE in the release
        srcpth = os.path.join(
            self._working_dir, target_dict["dirname"], target_dict["srcdir"]
        )
        fpth = os.path.join(srcpth, "Utilities", "version.f90")
        with open(fpth) as f:
            lines = f.read().splitlines()
        assert len(lines) > 0, f"could not update {srcpth}"

        f = open(fpth, "w")
        for line in lines:
            tag = "IDEVELOPMODE = 0"
            if tag in line:
                line = line.replace(tag, "IDEVELOPMODE = 1")
            f.write(f"{line}\n")
        f.close()

        # build release source files with Meson
        root_path = os.path.join(self._working_dir, target_dict["dirname"])
        bin_path = os.path.abspath(self._builtbin)
        meson_build(
            prj_path=os.getcwd(),
            bld_path=root_path,
            bin_path=bin_path,
            lib_path=bin_path,
        )


def download_and_unzip(
    url,
    pth="./",
    delete_zip=True,
    timeout=30,
    max_requests=10,
    chunk_size=2048000,
    verbose=False,
):
    """Download and unzip a zip file from a url.
    Parameters
    ----------
    url : str
        url address for the zip file
    pth : str
        path where the zip file will be saved (default is the current path)
    delete_zip : bool
        boolean indicating if the zip file should be deleted after it is
        unzipped (default is True)
    timeout : int
        url request time out length (default is 30 seconds)
    max_requests : int
        number of url download request attempts (default is 10)
    chunk_size : int
        maximum url download request chunk size (default is 2048000 bytes)
    verbose : bool
        boolean indicating if output will be printed to the terminal
    Returns
    -------
    """

    # create download directory
    if not os.path.exists(pth):
        if verbose:
            print(f"Creating the directory:\n    {pth}")
        os.makedirs(pth)

    if verbose:
        print(f"Attempting to download the file:\n    {url}")

    # define the filename
    file_name = os.path.join(pth, url.split("/")[-1])

    # download the file
    success = False
    tic = timeit.default_timer()

    # open request
    req = get_request(
        url,
        timeout=timeout,
        max_requests=max_requests,
        verbose=verbose,
    )

    # get content length, if available
    tag = "Content-length"
    if tag in req.headers:
        file_size = req.headers[tag]
        len_file_size = len(file_size)
        file_size = int(file_size)

        bfmt = "{:" + f"{len_file_size}" + ",d}"
        sbfmt = "{:>" + f"{len(bfmt.format(int(file_size)))}" + "s} bytes"
        msg = f"   file size: {sbfmt.format(bfmt.format(int(file_size)))}"
        if verbose:
            print(msg)
    else:
        file_size = 0.0

    # download data from url
    for idx in range(max_requests):
        # print download attempt message
        if verbose:
            print(f" download attempt: {idx + 1}")

        # connection established - download the file
        download_size = 0
        try:
            with open(file_name, "wb") as f:
                for chunk in req.iter_content(chunk_size=chunk_size):
                    if chunk:
                        # increment the counter
                        download_size += len(chunk)

                        # write the chunk
                        f.write(chunk)

                        # write information to the screen
                        if verbose:
                            if file_size > 0:
                                download_percent = float(
                                    download_size
                                ) / float(file_size)
                                msg = (
                                    "     downloaded "
                                    + sbfmt.format(bfmt.format(download_size))
                                    + " of "
                                    + bfmt.format(int(file_size))
                                    + " bytes"
                                    + f" ({download_percent:10.4%})"
                                )
                            else:
                                msg = (
                                    "     downloaded "
                                    + sbfmt.format(bfmt.format(download_size))
                                    + " bytes"
                                )
                            print(msg)
                        else:
                            sys.stdout.write("")
                            sys.stdout.flush()

                success = True
        except:
            # reestablish request
            req = get_request(
                url,
                timeout=timeout,
                max_requests=max_requests,
                verbose=verbose,
            )

            # try to download the data again
            continue

        # terminate the download attempt loop
        if success:
            break

    # write the total download time
    toc = timeit.default_timer()
    tsec = toc - tic
    if verbose:
        print(f"\ntotal download time: {tsec} seconds")

    if success:
        if file_size > 0:
            if verbose:
                print(f"download speed:      {file_size / (1e6 * tsec)} MB/s")
    else:
        msg = f"could not download...{url}"
        raise ConnectionError(msg)

    # Unzip the file, and delete zip file if successful.
    if "zip" in os.path.basename(file_name) or "exe" in os.path.basename(
        file_name
    ):
        z = MFZipFile(file_name)
        try:
            # write a message
            if not verbose:
                sys.stdout.write("\n")
            print(f"uncompressing...'{file_name}'")

            # extract the files
            z.extractall(pth)
        except:
            p = "Could not unzip the file.  Stopping."
            raise Exception(p)
        z.close()
    elif "tar" in os.path.basename(file_name):
        ar = tarfile.open(file_name)
        ar.extractall(path=pth)
        ar.close()

    # delete the zipfile
    if delete_zip:
        if verbose:
            print("Deleting the zipfile...")
        os.remove(file_name)

    if verbose:
        print("Done downloading and extracting...\n")

    return success
